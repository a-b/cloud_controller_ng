TABLE_BASE_NAMES = %w[
  app
  build
  buildpack
  deployment
  domain
  droplet
  isolation_segment
  organization
  package
  process
  revision
  route_binding
  route
  service_binding
  service_broker
  service_broker_update_request
  service_instance
  service_key
  service_offering
  service_plan
  space
  stack
  task
  user
].freeze
annotation_tables = TABLE_BASE_NAMES.map { |tbn| "#{tbn}_annotations" }.freeze
label_tables = TABLE_BASE_NAMES.map { |tbn| "#{tbn}_labels" }.freeze

def unique_index_name(table)
  "#{table}_unique".to_sym
end

Sequel.migration do
  up do
    annotation_tables.each do |table|
      transaction do
        # Just allow selects on this table while the migration runs for full consistency
        run "LOCK TABLE #{table} IN SHARE MODE;" if database_type == :postgres
        run "LOCK TABLES #{table} WRITE, #{table} AS subquery WRITE;" if database_type == :mysql

        # Adding a temporary column
        drop_column(:temp_key) if self.schema(table.to_sym).map(&:first).include?(:temp_key)
        add_column table.to_sym, :temp_key, String, size: 63

        # Updating the temporary column with truncated keys(should never chop of anything since the api just allows 63 chars)
        # We run this in the DB as to minimize the time we hold the share mode lock on the table
        self[table.to_sym].update(temp_key: Sequel::SQL::Function.new(:SUBSTR, :key, 1, 63))

        # Removing the original 'key' column
        drop_column table.to_sym, :key if self.schema(table.to_sym).map(&:first).include?(:key)

        # Renaming the temporary column back to 'key'
        rename_column table.to_sym, :temp_key, :key

        # Make en empty string the default for key_prefix as null in the unique constraint would not work.
        # Null values are not equal to other Null values so a row that has NULL can be a duplicate then.
        self[table.to_sym].where(key_prefix: nil).update(key_prefix: '')
        alter_table(table.to_sym) do
          set_column_default :key_prefix, ''
          set_column_not_null :key_prefix
          set_column_not_null :key
        end

        # Delete duplicates (in the DB as doing it in ruby is slow), we need to alias the sub-query as
        # mysql requires also a lock on the sub-queries table for some weird reason
        min_ids_subquery = self.from("#{table}___subquery".to_sym).
                           select(Sequel.function(:MIN, :id).as(:min_id)).
                           group_by(:resource_guid, :key_prefix, :key)
        self[table.to_sym].exclude(id: min_ids_subquery).delete

        # Add unique constraint if not already present
        if self.indexes(table.to_sym)[unique_index_name(table)].nil?
          alter_table(table.to_sym) do
            add_unique_constraint [:resource_guid, :key_prefix, :key], name: unique_index_name(table)
          end
        end
      end
      # Be sure to unlock the table afterwards as this does not happen automatically after committing a transaction in mysql
      run 'UNLOCK TABLES;' if database_type == :mysql
    rescue Sequel::DatabaseError
      # Clean up potential temporary assets left behind
      drop_column(:temp_key) if self.schema(table.to_sym).map(&:first).include?(:temp_key)
      drop_table?(:tmp_table)
      # Be sure to unlock the table on errors as this does not happen automatically by rolling back a transaction mysql
      run 'UNLOCK TABLES;' if database_type == :mysql
      raise
    end

    label_tables.each do |table|
      transaction do
        # Lock table while the migration runs for full consistency. Mysql requires also locks on tables generated by sub-queries.
        run "LOCK TABLE #{table} IN SHARE MODE;" if database_type == :postgres
        run "LOCK TABLES #{table} WRITE, #{table} AS subquery WRITE;" if database_type == :mysql

        # Make en empty string the default for key_prefix as null in the unique constraint would not work.
        # Null values are not equal to other Null values so a row that has NULL can be a duplicate then.
        self[table.to_sym].where(key_prefix: nil).update(key_prefix: '')
        alter_table(table.to_sym) do
          set_column_default :key_prefix, ''
          set_column_not_null :key_prefix
          set_column_not_null :key_name
        end

        # Delete duplicates (in the DB as doing it in ruby is slow), we need to alias the sub-query as
        # mysql requires also a lock on the sub-queries table for some weird reason
        min_ids_subquery = self.from("#{table}___subquery".to_sym).
                           select(Sequel.function(:MIN, :id).as(:min_id)).
                           group_by(:resource_guid, :key_prefix, :key_name)
        self[table.to_sym].exclude(id: min_ids_subquery).delete

        # Add unique constraint if not already present
        if self.indexes(table.to_sym)[unique_index_name(table)].nil?
          alter_table(table.to_sym) do
            add_unique_constraint [:resource_guid, :key_prefix, :key_name], name: unique_index_name(table)
          end
        end
      end
      # Be sure to unlock the table afterwards as this does not happen automatically after committing a transaction in mysql
      run 'UNLOCK TABLES;' if database_type == :mysql
    rescue Sequel::DatabaseError
      # Clean up potential temporary assets left behind
      drop_table?(:tmp_table)
      # Be sure to unlock the table on errors as this does not happen automatically by rolling back a transaction mysql
      run 'UNLOCK TABLES;' if database_type == :mysql
      raise
    end
  end

  down do
    annotation_tables.each do |table|
      transaction do
        # Drop unique constraint
        drop_index table.to_sym, nil, name: unique_index_name(table) unless self.indexes(table.to_sym)[unique_index_name(table)].nil?
        # Revert column size of annotation tables back to 1000
        set_column_type table.to_sym, :key, String, size: 1000
        # Revert default type in key_prefix and null values handling
        alter_table(table.to_sym) do
          set_column_allow_null :key_prefix
          set_column_allow_null :key
          set_column_default :key_prefix, nil
        end
        # Apply the old default value everywhere
        self[table.to_sym].where(key_prefix: '').update(key_prefix: nil)
      end
    end
    label_tables.each do |table|
      transaction do
        # Drop unique constraint
        drop_index table.to_sym, nil, name: unique_index_name(table) unless self.indexes(table.to_sym)[unique_index_name(table)].nil?
        # Revert default type in key_prefix and null values handling
        alter_table(table.to_sym) do
          set_column_allow_null :key_prefix
          set_column_allow_null :key_name
          set_column_default :key_prefix, nil
        end
        # Apply the old default value everywhere
        self[table.to_sym].where(key_prefix: '').update(key_prefix: nil)
      end
    end
  end
end
